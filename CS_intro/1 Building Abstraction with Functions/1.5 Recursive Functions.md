## Recursive Functions 递归函数

什么是递归函数？简单讲，就是如果函数体调用了函数本身，要么直接调用，要么间接调用，那这个函数就是递归函数。换句话讲，执行递归函数的过程中，函数可能需要应用自身。我们借用一下[Wikipedia](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))上的定义：
递归（英语：recursion）在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。[1] 递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念。绝大多数编程语言支持函数的自调用，在这些语言中函数可以通过调用自身来进行递归。计算理论可以证明递归的作用可以完全取代循环，因此有很多在函数编程语言（如Scheme）中用递归来取代循环的例子。
在Python中写递归其实并不复杂，我们可以先参考(这一节)[https://www.composingprograms.com/pages/17-recursive-functions.html]的内容，对递归有一个大致的了解，熟悉一下是什么。
<br>
很有趣的是，在自然语言中，我们会无意识的去应用递归这种结构。考虑这个句子
- *"The cat that the dog chased ran away."*
在这个句子中，"The cat ran away" 是一个完整的句子。但是我们在主语 "cat" 后面嵌入了另一个句子 "that the dog chased" 来修饰 "cat"。这个嵌套结构可以继续延伸：
- "The cat that the dog that the boy scared chased ran away."
在这个句子中，"The dog that the boy scared" 嵌套在 "The cat that the dog chased" 里面，从而形成了递归结构。
再考虑一段套娃的对话：
- 他们在撒谎
- 我们知道（他们在撒谎）
- 他们知道[我们知道(他们在撒谎)]
- 我们也知道{他们知道[我们知道(他们在撒谎)]}
人类语言的独特性在于可以用有限的规则与参数创造出无限的句子，这个特点便意味着人类的语言系统具有生成性。如果对生成语法感兴趣可以去知乎上看看这篇文章[^1] 。

Language is:
- A finite set of fundamental principles that are common to all languages。
- A finite set of parameters that determine syntactic variability among languages
——Norm Chomsky
而提到生成语法就不得不提一嘴乔姆斯基老爷子了，乔姆斯基对语言层级的划分主要体现在他提出的乔姆斯基层级（Chomsky Hierarchy），这是一种用于分类各种文法和语言的理论框架。乔姆斯基层级主要分为四个级别，从低到高分别是：有限状态文法、上下文无关文法、上下文相关文法和递归可枚举文法。这些层级在形式语言理论中尤其重要，广泛应用于计算机科学和语言学中。我们这里快速的介绍下这个框架，如果有兴趣的话可以这本书[^2]
1. 递归可枚举文法（零型文法）：这是最复杂的文法类型，理论上可以生成任何可能的语言，包括所有计算机程序的输出。这种文法的解析和执行通常非常复杂，甚至可能是不可判定的。
2. 上下文相关文法（一型文法）：这类文法更加复杂，可以生成的语言包括某些自然语言和复杂的数据结构。在计算机科学中，这类文法用于解决某些特定的算法问题，但由于其解析过程通常较为复杂，实际应用较少。
3. 上下文无关文法（二型文法）：这类文法可以生成更复杂的语言结构，如程序设计语言中的表达式和语句。编程语言的语法大多是上下文无关的，因为它允许设计复杂的嵌套结构，例如括号匹配和树形结构，常见于编译器的设计。
4. 有限状态文法（三型文法）：这种文法由有限的状态和转换规则构成，适用于描述简单的结构，如正则表达式和有限自动机。在计算机科学中，它通常用于设计文本搜索模式和分析简单的输入数据。

一般我们认为编程语言大多数位于上下文无关文法这一层级，因为这能够很好地描述编程语言中常见的结构，如函数、循环和条件语句，且相对容易通过编译器进行解析和处理。上下文无关语法由四个部分组成：
- 非终结符（Non-terminal symbols）：这些是语法的变量，代表了可以被进一步替换和扩展的语言的组成部分。
- 终结符（Terminal symbols）：这些是语言的基本单位，不可进一步分解。在编程语言中，例如，终结符可能包括关键字、操作符、数值等。
- 产生式规则（Production rules）：这些规则定义了非终结符如何被终结符或非终结符的序列替换和重新组合。
- 起始符号（Start symbol）：定义了产生式规则开始应用的非终结符。

以简单的数学表达式语法为例，其CFG可能如下：
- 非终结符：Expr, Term, Factor
= 终结符：+, *, (, ), 数字
- 产生式规则：
    - Expr → Expr + Term | Term
    - Term → Term * Factor | Factor
    - Factor → ( Expr ) | 数字
- 起始符号：Expr
此例中，Expr、Term和Factor非终结符通过递归产生式规则相互定义，支持加法和乘法运算，以及括号内的表达式求值。
上下文无关语法的这种能力使其成为理解和构建复杂语言结构的强大工具，尽管它也有其局限性，例如在处理某些自然语言现象时的困难。

聊了这么多，让我们回到递归这个概念，我们首先来探讨一下汉诺塔这个经典的智力游戏。它是由法国数学家爱德华·卢卡斯于1883年发明的．给定一个由8个圆盘组成的塔，这些圆盘按照大小递减的方式套在三根桩柱中的一根上。我们的目的是要将整个塔移动到另一根桩柱上，每次只能移动一个圆盘，且较大的圆盘在移动过程中不能放置在较小的圆盘上面，最少要移动多少次才能完成这个任务。
乍一眼看下去这个问题似乎有些棘手，而解决这类问题最好的办法是先将这个问题推广，换言之，便是把这个八个圆盘的问题转换为n个圆盘的问题。
这样推广的好处在于我们可以先从小问题入手，再根据数学归纳法推广到更一般的情况。我们先引入一些记号来方便命名与求解。我们说$T_n$是这个问题的最优解，也就说对于一个n层的汉诺塔，我们*至少*要通过$T_n$次移动，才能把整个塔移动到另一根桩柱上，而且较大的圆盘在移动过程中不能放置在较小的圆盘上面。
我们很容易可以观察到当层数比较低时，$T_1 = 1 , T_2 = 3$。而从这两个情况我们还能知道$T_0=0$，也就是0个圆盘的汉诺塔不需要任何移动。
那么当n比较大的时候，我们要怎么操作呢，我们在前两个例子中看到，我们的做法是先将$n-1$个小的圆盘移到一个不同的柱上，然后移动底下最大的圆盘，然后再把那n-1个小圆盘移动到那个最大的圆盘上面去。
我们用数学的语言重新描述一下，就是我们需要进行$T_{n-1}$次移动，将$n-1$个圆盘移开,然后再进行$T_{n-1}$次移动把移开的圆环移到最大的圆环底下，所以$T_n \le 2T_{n-1} + 1$。
但是现在我们只给出了一个上限，那么是否存在更好地方法使得$T_n$更小呢？实际上没有，考虑到我们要将$n-1$个小的圆盘移到一个不同的柱上，这就需要要$T_{n-1}$次移动，而将$n-1$个圆盘移到最大的圆盘底下，同样需要$T_{n-1}$次移动，如果我们在这两个移动的过程中间犯了一些小错误，那我们会移动次数增加。所以我们可以得到$T_n \geq 2 T_{n-1} + 1$。
结合两个两个等式与$n=0$的平凡解，我们可以得到
$T_0 = 0$
$T_n = 2^n + 1，n \ge 0$

而上面这一组式子我们称为递归式。它给出一个边界值，以及一个推导一般情况的方程。有时我们也把单一的那个方程成为递归式，不过理论上他还需要一个边界值。
我们用python代码表示这个递归式：
```py
def Hanoi(n):
    if (n == 0):
        return 0
    elif (n > 0):
        return 2*Hanoi(n-1) + 1
```
一般来说当n变得很大时，我们并不会用递归式去求值，因为太耗时了。其中的原因在于递归式只给出了一个局部的信息，而计算$T_n$是需要从头开始获取前面的局部信息，所以说我们需要一个递归式的"封闭"解(通项公式)，这个解可以直接计算出$T_n$,甚至当n很大的时候也一样可以。
那么如何求解呢，一个办法是用惊人的注意力不难发现$T_n$的递归解是$T_n = 2^n - 1$。但是这不严谨，而且当这个递归式变得复杂的时候，我们很难直接观察到这样一个递归解。
这时候我们就需要数学归纳法登场了。数学归纳法（mathematical induction）是证明某个命题对所有满足 $n \geq n_0$ 的整数 $n$ 都成立的一般方法．首先我们在 $n$ 取最小值 $n_0$ 时证明该命题，这一步骤称为基础（basis）；然后
对 $n>n_0$ ，假设该命题对 $n_0$ 与 $n>n_0$之间（包含它们在内）的所有值都已经被证明，再证明该命题对 $n$ 成立，这一步骤称为归纳（induction）。这样一种证明方法仅用有限步就得到无限多个结果。
而对于这个例子来说数学归纳法确实可以证明得到这个递归解
河内塔的递归式是在各种应用中出现的诸多问题的一个典范．在寻求像$T_n$ 这样有意义的量的封闭形式的表达式时，我们经过了如下三个阶段。
(1) 研究小的情形．这有助于我们洞察该问题，而且对第二和第三阶段有所帮助．
(2) 对有意义的量求出数学表达式并给出证明．对河内塔，这就是递归式，它允许我们对任何$n$算$T_n$ （假设我们有这样的意向）.
(3) 对数学表达式求出封闭形式并予以证明．对河内塔，这就是求递归解。

我们在这里先不谈怎么求出这个递归解，如果有兴趣的话可以去看看这本《具体数学》[^3]，上面这个例子就是从这本书中选的。

再次回到正题，那么我们要怎么写递归函数呢？
有了上面的铺垫，我们可以可以归纳一下步骤：
1. 找出递归式，也就是递归函数的主体部分。
2. 找到一个特殊值（通常是一个边界值）
3. 每次调用函数时根据递推式缩小问题的规模。
考虑一个经典的走楼梯的问题：想象一下，你想要走上一个有 n 级台阶的楼梯，其中n是一个正整数。每次移动可以一次迈一步或两步。有多少种方法可以走完整个楼梯？
对于这个问题，我们可以使用递归函数来解决。
不难发现n级台阶的走法可以由n-1级台阶和n-2级台阶组成，所以问题可以分解为两个子问题，即走n-1级台阶和走n-2级台阶。而初始情况是什么呢？初始情况就是走1级台阶和走2级台阶。于是我们可以得到下面这个函数
```py
def count_ways_recursive(n):
    if n == 0 or n == 1:
        return 1  # One way to stay on the ground or take one step to the first stair.
    if n < 0:
        return 0  # No way to climb negative steps.
    return count_ways_recursive(n - 1) + count_ways_recursive(n - 2)
```
对于默认的return语句中的```return count_ways_recursive(n - 1) + count_ways_recursive(n - 2)```，最开始写这种递归的时候可能会困惑这样写真的能求出来正确的答案吗？实际上，我们可以把它理解为对这是子问题的一个抽象，我们不需要知道它在做什么，只需要知道它在求解一个子问题就可以了。这一步我们称之为递归的信仰之跃(Recursive Leap of Faith)。
还有一个经典的例子便是归并排序(merge sort)，感兴趣的同学可以去OI Wiki上看看。[^4]
[^1]:https://zhuanlan.zhihu.com/p/596630883
[^2]:http://infolab.stanford.edu/~ullman/ialc.html
[^3]:http://cslabcms.nju.edu.cn/problem_solving/images/0/06/Concrete_Mathematics_-_R._Graham%2C_D._Knuth%2C_O._Patashnik.pdf
[^4]:https://oi-wiki.org/basic/divide-and-conquer/