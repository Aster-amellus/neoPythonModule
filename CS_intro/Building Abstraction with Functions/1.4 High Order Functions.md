## High Order Functions and Lambda


从之前的章节里可以看到，函数作为一种抽象方法，描述的是与其参数的特定值无关的复合运算。
例如，在`square`函数中
```python
def square(x):
    return x * x
```
我们讨论的不是获取某个特定数字平方的方法，而是在讨论获取任意数字的平方的一种方法。
对于简单诸如求平方这类的简单过程，我们可以不显式的使用square函数，而是直接编写下面的表达式。
```python
>>> 3 * 3
9
>>> 4 * 4
16
```
但是对于更复杂的过程，这种做法就变得不够优雅且较为困难了（如求fibonacci数列或开平方）。
一般来说，缺乏函数定义(function definition)会让我们编写程序变得相当困难，因为这将迫使我们始终在特定运算的层次上工作，而这些运算恰好是语言中的基元运算（本例中为乘法），而不是更高层次的运算。因此，虽然我们的程序可以计算平方，但我们的语言却缺乏表达平方概念的能力，这就把事情变得更加繁琐了。

因此，我们对功能强大的编程语言的要求之一，就是能够通过为常见模式命名的方式来建立抽象，然后直接根据这些名称进行工作。而函数提供了这种能力。正如我们将在下面的示例中看到的，有一些常见的编程模式(programming patterns)会在代码中重复出现，给这种相同的模式编写相似的函数，增加了不必要的重复。而通过给这些模式命名，我们可以把它们抽象化（再次增加一层**抽象壁垒**），从而写出清晰的代码。

而为了以命名概念的形式表达某些一般模式，我们需要构造一些函数，这些函数可以接受其他函数作为参数，也可以返回函数作为值。操纵函数的函数称为**高阶函数**。本节将展示高阶函数如何作为强大的抽象机制，极大地增强我们语言的表达能力。


#### *Functions as Argument 函数作为参数*
考虑下面三个函数
第一个函数计算了不大于n的自然数之和：
```python
def sum_naturals(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k, k + 1
        return total
```
第一个函数计算了不大于n的自然数之立方和：
```python
def sum_naturals(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k*k*k, k + 1
        return total
```
第三个函数计算下面这个数列到n的和(收敛至$\pi$)：
$\frac{8}{1\times 3}+\frac{8}{5\times 7}+...+ \frac{8}{4n-1\times 4n-3}$ 
```py
def pi_sum(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + 8 / ((4*k-3) * (4*k-1)), k + 1
        return total
```
这三个程序显然共享了一个共同的基本模式。它们在很大程度上是相同的，只有步骤的名称、用于计算要添加的项的 a 函数，以及提供 a 下一个值的函数有所不同。我们可以通过在相同的模板中填充\<term>来生成每个程序：
```py
def <name>(n):
    total, k = 0, 1
    while k <= n:
        total, k = total + <term>(k), k + 1
    return total
```
这种常见模式的出现，有力地证明了有一个有用的抽象概念正等待着我们去挖掘。事实上，数学家很久以前就确定了级数求和的抽象，并发明了“σ符号”来表示这个概念，例如
$\sum_{n=a}^b f(n) = f(a) + f(a+1) + ... + f(b-1) + f(b)$
σ符号的威力在于它允许数学家处理求和概念本身，而不仅限于特定的求和问题。例如，可以对无论特定的求和序列如何进行求和，得出一般性的求和结果。

同样，作为程序设计者，我们希望我们的语言足够强大，这样我们就能编写出表达求和概念本身的程序，而不仅仅是计算特定和的程序。在我们的程序语言中，我们可以很容易地做到这一点，方法是采用上图所示的通用模板，并将上面的\<term>转化为形式参数：
在下面的示例中，求和的两个参数是上界 n 和计算第 k 项的函数项。我们可以像使用任何函数一样使用求和，它能简洁地表达求和。请花点时间看一下这个例子，注意将 cube 与本地名称项绑定后，$1*1*1 + 2*2*2 + 3*3*3 = 36$ 的结果是如何正确计算的。
```py
def summation(n, term): def summation(n, term):
2	    total, k = 0, 1
3	    while k <= n:
4	        total, k = total + term(k), k + 1
5	    return total return 
6	
7	def cube(x):
8	    return x*x*x
9	
10	def sum_cubes(n):
11	    return summation(n, cube)
12	
13	result = sum_cubes(3)
```
使用返回其输入的参数的 identity 函数，我们还可以使用完全相同的 summation 函数求和自然数。
```py
>>> def summation(n, term):
        total, k = 0, 1
        while k <= n:
            total, k = total + term(k), k + 1
        return total
>>> def identity(x):
        return x
>>> def sum_naturals(n):
        return summation(n, identity)
>>> sum_naturals(10)
55
```
summation 函数也可以直接调用，无需为特定序列定义另一个函数。
```py
>>> summation(10, square)
385
```
可以通过使用我们的抽象 summation 来定义 pi_sum ，通过定义一个函数 pi_term 来计算每个项。我们将参数 1e6 （ 1 * 10^6 = 1000000 的简写）传递进去，以生成一个接近 π 的近似值。
```py
>>> def pi_term(x):
        return 8 / ((4*x-3) * (4*x-1))
>>> def pi_sum(n):
        return summation(n, pi_term)
>>> pi_sum(1e6)
3.141592153589902
```
有了summation 函数，我们可以将其作为构建进一步概念的基石。例如求函数$f(x)$在a到b上的定积分。有兴趣的同学可以在MIT开源的教材[SICP](https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-12.html)找到一些习题。不过需要注意的是，MIT使用Scheme(一种函数式编程语言Lisp的方言)作为其教学语言，但是影响不大，能稍微领会其，知道写的函数在干什么就足够了。


#### *Functions as General Methods 函数作为一般性的方法*
我们介绍过用户自定义函数，它是一种对数字运算模式进行抽象的机制，从而使运算与所涉及的特定数字无关。有了高阶函数，我们开始看到一种更强大的抽象：一些函数表达了通用的计算方法，与它们调用的特定函数无关。

尽管我们对函数的含义进行了概念上的扩展，但我们关于如何评估调用表达式的环境模型仍可优雅地扩展到高阶函数的情况，而不会发生任何变化。当用户定义的函数被应用到某些参数时，形式参数会被绑定到新的局部框架中的参数值（可能是函数）。

请看下面的示例，它实现了迭代改进的一般方法，并用于计算黄金分割率。黄金分割率通常被称为 "phi"，是一个接近 1.6 的数字，经常出现在自然、艺术和建筑中。

迭代改进算法从方程解的猜测开始。它反复应用一个更新函数来改进这个猜测，并应用近似比较来检查当前的猜测是否 "足够接近 "被认为是正确的。
```py
>>> def improve(update, close, guess=1):
        while not close(guess):
            guess = update(guess)
        return guess
        
```

这个`improve`函数是重复的细节的一般表达式。它没有说明要解决的问题是什么：这些细节都留给了作为参数传递进来的`update`和` close `函数。
我们在小学二年级学过,黄金分割率有两个的特性，一是可以通过重复求任何正数的倒数与 1 的和来计算，二是黄金分割率比它的平方小 1。我们可以将这些性质表示为可以被`improve`使用的函数。
```py
>>> def golden_update(guess):
        return 1/guess + 1
>>> def square_close_to_successor(guess):
        return approx_eq(guess * guess, guess + 1)
```

以上，我们介绍了一个调用 `approx_eq` 的函数，如果其参数彼此近似相等，则返回 `True` 。要实现`approx_eq` ，我们可以将两个数字之间的差的绝对值与一个小的容差值进行比较。

```py
>>> def approx_eq(x, y, tolerance=1e-15):
        return abs(x - y) < tolerance
```
调用 `improve` ，使用参数 `golden_update` 和 `square_close_to_successor` 将计算黄金比例的有限近似值。
```py
>>> improve(golden_update, square_close_to_successor)
1.6180339887498951
```

这个例子说明了计算机科学中的两个相关的重要思想。首先，命名和函数可以使我们把大量的复杂性抽象化。虽然每个函数定义都很简单，但我们的评估过程引发的计算过程非常复杂。其次，正是由于我们对 Python 语言有一个非常普遍的评估过程，所以可以将小组件组合成复杂的过程。理解程序的解释过程使我们能够验证和检查我们创建的过程。

像往常一样，我们新的通用方法 `improve` 需要一个测试来检查其正确性。黄金比率可以提供这样一个测试，因为它也有一个精确的闭式解，我们可以将其与这个迭代结果进行比较。
```py
>>> from math import sqrt
>>> phi = 1/2 + sqrt(5)/2
>>> def improve_test():
        approx_phi = improve(golden_update, square_close_to_successor)
        assert approx_eq(phi, approx_phi), 'phi differs from its approximation'
>>> improve_test()
```
对于这个测试，没有消息就是好消息： `improve_test` 在其 `assert` 语句执行成功后返回 None 。
#### *Functions as Return Value 函数作为返回值*

上面的示例说明了，将函数作为参数能极大地增强了编程语言的表达能力。通过创建返回值本身就是函数的一类函数，我们甚至可以获得更强的表达能力。

一旦定义了许多简单的函数，函数组合就自然而然地成为我们编程语言中的一种组合方法。也就是说，给定两个函数 `f(x)` 和 `g(x)`，我们可能想定义 `h(x)` = `f(g(x))`。我们可以使用现有工具定义函数组合：
```py
def compose1(f, g):
    def h(x):
        return f(g(x))
    return h
```
接下来我们来看一个拓展示例，它是我们前文提到的牛顿迭代法更为一般化的版本。

牛顿法是一种经典的迭代方法，用于找到数学函数的参数，使其返回值为 0。这些值被称为函数的零点。找到函数的零点通常等价于解决其他感兴趣的问题，比如计算平方根。

牛顿法是一种迭代改进算法：它改进了对任何可微分函数零点的猜测，这意味着它可以在任意点用直线逼近。牛顿法根据这些直线近似值来寻找函数的零点。

试想一条通过点$(𝑥,𝑓(𝑥))$的直线，其斜率与函数$𝑓(𝑥)$在该点的曲线相同。这样的直线称为切线，其斜率称为$𝑓$在$𝑥$处的导数。对于函数$f$及其导数$df$，`newton_update` 表示沿着这条切线到 0 的计算过程。
```py
def newton_update(f, df):
    def update(x):
        return x - f(x) / df(x)
    return update
```
接着，我们可以通过定义一个使用`newton_update`和`improve`的`find_root`函数来查看$f(x)$是否接近0.
```py
def find_zero(f, df):
    def near_zero(x):
        return approx_eq(f(x), 0)
    return improve(newton_update(f, df), near_zero)
```
利用牛顿法，我们可以计算任意𝑛次的根$𝑥⋅𝑥⋅...⋅𝑥=𝑎$。一般地，求$n$的$a$次方和求函数$x^n -a =0 $是等价的。

考虑最简单的求平方根，我们首先定义函数$f$和它的导数$df$。利用一些初等的微积分知识，我们知道$f(x)=x^2-a$，$df(x)=2x$。因此，下面我们用定义一个求平方根的函数。
```py
def square_root_newton(a):
    def f(x):
        return x * x - a
    def df(x):
        return 2 * x
    return find_zero(f, df)
```
```py
>>>square_root_newton(64)
8.0
```
我们把求根的方法一般化到求任意次方根$n$，我们计算 $f(x)=x^n−a$及其导数 $df(x)=n⋅ x^{n−1}$
 。
 ```py
 >>> def power(x, n):
        """Return x * x * x * ... * x for x repeated n times."""
        product, k = 1, 0
        while k < n:
            product, k = product * x, k + 1
        return product
>>> def nth_root_of_a(n, a):
        def f(x):
            return power(x, n) - a
        def df(x):
            return n * power(x, n-1)
        return find_zero(f, df)
>>> nth_root_of_a(2, 64)
8.0
>>> nth_root_of_a(3, 64)
4.0
>>> nth_root_of_a(6, 64)
2.0
```
不过需要注意的是使用牛顿法时，它并不总是收敛的。初始猜测值 `improve `必须足够接近零，并且必须满足关于函数的各种条件。尽管存在这些缺陷，牛顿法是一种强大的通用计算方法，用于解决可微方程。现代计算机中用于对数和大整数除法的快速算法采用了这种技术的变体。
#### *Curry 柯里化*
~~柯里化是一种把接受多个参数的函数转换成咖喱的技术~~
柯里化的主要思想是将一个$n$元函数转换为$n$个一元函数的嵌套调用。例如，原始函数$f(a, b, c)$ 可以被转换为$f(a)(b)(c)$。这种技术在函数式编程中非常常见，有助于函数的部分应用（Partial Application），即固定函数的一些参数，从而生成一个新的函数。换句话说，柯里化函数每次只接受一个参数，并返回一个新的函数，直到所有参数都被接受为止。
下面是一个柯里化pow函数的例子：
```py
>>>def curried_pow(x):
    def inner(y):
        return pow(x, y)
    return inner
>>>cured_pow(2)(3)
8
```
一些编程语言，如 Haskell，只允许接受单个参数的函数，因此程序员必须对所有多参数过程进行柯里化。在诸如 Python 之类的更一般的语言中，当我们需要一个只接受一个参数的函数时，柯里化也是有用的。例如，`map`函数将单参数函数应用于一系列值。在后面的章节中，我们将看到更一般的映射模式的示例，但现在，我们可以在一个函数中实现该模式：
```py
>>> def map_to_range(start, end, f):
        while start < end:
            print(f(start))
            start = start + 1
```
我们可以使用 `map_to_range` 和 `curried_pow` 来计算 2 的前十次幂，而不是专门编写一个函数来实现：
```py
>>> map_to_range(0, 10, curried_pow(2))
1
2
4
8
16
32
64
128
256
512
```
类似地，我们可以使用相同的两个函数来计算其他数字的幂。科里化使我们我们无需为每个要计算幂的数字编写特定函数，就能完成计算。
在上面的例子中，我们手动对 `pow` 函数进行了柯里化变换，得到了 `curried_pow` 。而实际上，我们可以定义一些函数来自动化柯里化，以及逆变换未柯里化：
```py
>>> def curry2(f):
        """Return a curried version of the given two-argument function."""
        def g(x):
            def h(y):
                return f(x, y)
            return h
        return g
>>> def uncurry2(g):
        """Return a two-argument version of the given curried function."""
        def f(x, y):
            return g(x)(y)
        return f
        >>> pow_curried = curry2(pow)
>>> pow_curried(2)(5)
32
>>> map_to_range(0, 10, pow_curried(2))
1
2
4
8
16
32
64
128
256
512
```
curry2 函数接受一个两参数函数 `f` ，并返回一个单参数函数 `g` 。当 `g` 应用于参数 x 时，它返回一个单参数函数 `h` 。当 `h` 应用于 `y` 时，它调用 `f(x, y)` 。因此， `curry2(f)(x)(y)` 等同于 `f(x, y)` 。 `uncurry2 `函数反转了柯里化转换，所以 `uncurry2(curry2(f))` 等同于 `f `。
#### *Lambda Functions lambda函数* 
#### *Abstraction and First-Class Functions 抽象机制与一等公民*
#### *Function Decorators 函数装饰器*
