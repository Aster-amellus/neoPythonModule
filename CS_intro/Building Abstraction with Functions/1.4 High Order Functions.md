## High Order Functions and Lambda


从之前的章节里可以看到，函数作为一种抽象方法，描述的是与其参数的特定值无关的复合运算。
例如，在```square```函数中
```python
def square(x):
    return x * x
```
我们讨论的不是获取某个特定数字平方的方法，而是在讨论获取任意数字的平方的一种方法。
对于简单诸如求平方这类的简单过程，我们可以不显式的使用square函数，而是直接编写下面的表达式。
```python
>>> 3 * 3
9
>>> 4 * 4
16
```
但是对于更复杂的过程，这种做法就变得不够优雅且较为困难了（如求fibonacci数列或开平方）。
一般来说，缺乏函数定义(function definition)会让我们编写程序变得相当困难，因为这将迫使我们始终在特定运算的层次上工作，而这些运算恰好是语言中的基元运算（本例中为乘法），而不是更高层次的运算。因此，虽然我们的程序可以计算平方，但我们的语言却缺乏表达平方概念的能力，这就把事情变得更加繁琐了。

因此，我们对功能强大的编程语言的要求之一，就是能够通过为常见模式命名的方式来建立抽象，然后直接根据这些名称进行工作。而函数提供了这种能力。正如我们将在下面的示例中看到的，有一些常见的编程模式(programming patterns)会在代码中重复出现，给这种相同的模式编写相似的函数，增加了不必要的重复。而通过给这些模式命名，我们可以把它们抽象化（再次增加一层**抽象壁垒**），从而写出清晰的代码。

而为了以命名概念的形式表达某些一般模式，我们需要构造一些函数，这些函数可以接受其他函数作为参数，也可以返回函数作为值。操纵函数的函数称为**高阶函数**。本节将展示高阶函数如何作为强大的抽象机制，极大地增强我们语言的表达能力。

---
- *Functions as Argument 函数作为参数*
考虑下面三个函数
第一个函数计算了不大于n的自然数之和：
```python
def sum_naturals(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k, k + 1
        return total
```
第一个函数计算了不大于n的自然数之立方和：
```python
def sum_naturals(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k*k*k, k + 1
        return total
```
第三个函数计算下面这个数列到n的和(收敛至$\pi$)：
$\frac{8}{1\times 3}+\frac{8}{5\times 7}+...+ \frac{8}{4n-1\times 4n-3}$ 
```py
def pi_sum(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + 8 / ((4*k-3) * (4*k-1)), k + 1
        return total
```
这三个程序显然共享了一个共同的基本模式。它们在很大程度上是相同的，只有步骤的名称、用于计算要添加的项的 a 函数，以及提供 a 下一个值的函数有所不同。我们可以通过在相同的模板中填充\<term>来生成每个程序：
```py
def <name>(n):
    total, k = 0, 1
    while k <= n:
        total, k = total + <term>(k), k + 1
    return total
```
这种常见模式的出现，有力地证明了有一个有用的抽象概念正等待着我们去挖掘。事实上，数学家很久以前就确定了级数求和的抽象，并发明了“σ符号”来表示这个概念，例如
$\sum_{n=a}^b f(n) = f(a) + f(a+1) + ... + f(b-1) + f(b)$
σ符号的威力在于它允许数学家处理求和概念本身，而不仅限于特定的求和问题。例如，可以对无论特定的求和序列如何进行求和，得出一般性的求和结果。
同样，作为程序设计者，我们希望我们的语言足够强大，这样我们就能编写出表达求和概念本身的程序，而不仅仅是计算特定和的程序。在我们的程序语言中，我们可以很容易地做到这一点，方法是采用上图所示的通用模板，并将上面的\<term>转化为形式参数：
在下面的示例中，求和的两个参数是上界 n 和计算第 k 项的函数项。我们可以像使用任何函数一样使用求和，它能简洁地表达求和。请花点时间看一下这个例子，注意将 cube 与本地名称项绑定后，$1*1*1 + 2*2*2 + 3*3*3 = 36$ 的结果是如何正确计算的。
```py
def summation(n, term): def summation(n, term):
2	    total, k = 0, 1
3	    while k <= n:
4	        total, k = total + term(k), k + 1
5	    return total return 
6	
7	def cube(x):
8	    return x*x*x
9	
10	def sum_cubes(n):
11	    return summation(n, cube)
12	
13	result = sum_cubes(3)
```
使用返回其输入的参数的 identity 函数，我们还可以使用完全相同的 summation 函数求和自然数。
```py
>>> def summation(n, term):
        total, k = 0, 1
        while k <= n:
            total, k = total + term(k), k + 1
        return total
>>> def identity(x):
        return x
>>> def sum_naturals(n):
        return summation(n, identity)
>>> sum_naturals(10)
55
```
summation 函数也可以直接调用，无需为特定序列定义另一个函数。
```py
>>> summation(10, square)
385
```
可以通过使用我们的抽象 summation 来定义 pi_sum ，通过定义一个函数 pi_term 来计算每个项。我们将参数 1e6 （ 1 * 10^6 = 1000000 的简写）传递进去，以生成一个接近 π 的近似值。
```py
>>> def pi_term(x):
        return 8 / ((4*x-3) * (4*x-1))
>>> def pi_sum(n):
        return summation(n, pi_term)
>>> pi_sum(1e6)
3.141592153589902
```
- Functions as General Methods 函数作为一般性的方法
- Nested Functions 嵌套函数
- Functions as Return Value 函数作为返回值
- Curry 柯里化 
- Lambda Functions lambda函数 
- Abstraction and First-Class Functions 抽象机制与一等公民
- Function Decorators 函数装饰器
